# Enterprise Dependency Management: Platform Package Approach

## Problem Statement

We have **10-15 independent UI repositories** (React apps), each with their own `package.json`, and **4-5 internally built npm packages** shared across them. Every time a vulnerability is found and fixed in one of these internal packages, we must manually update all 10-15 repos — a process that is time-consuming, error-prone, and doesn’t scale.

## Solution: The Platform Package Pattern

Create a single **meta-package** (`@yourorg/platform`) that acts as the centralized source of truth for all shared internal dependencies. Each UI repo depends only on this one package, and updates propagate automatically via semver.

This is the pattern used by companies like Google, Shopify, and Spotify for exactly this problem.

-----

## Architecture Overview

```
┌──────────────────────────────────────────────────┐
│         @yourorg/platform (Centralized Repo)     │
│                                                  │
│  package.json defines:                           │
│    @yourorg/ui-components   : 2.3.2              │
│    @yourorg/shared-utils    : 3.1.4              │
│    @yourorg/auth-helpers    : 1.5.0              │
│    @yourorg/api-client      : 4.0.1              │
│    @yourorg/theme-config    : 1.2.0              │
│                                                  │
│  Publishes to private npm registry               │
└──────────────────┬───────────────────────────────┘
                   │
                   │  Published as @yourorg/platform@5.x.x
                   ▼
       ┌───────────────────────┐
       │  Private NPM Registry │
       │  (GitHub Packages /   │
       │   Artifactory / etc.) │
       └───────────┬───────────┘
                   │
       ┌───────────┼───────────────────────┐
       │           │                       │
       ▼           ▼                       ▼
  ┌─────────┐ ┌─────────┐           ┌─────────┐
  │UI Repo 1│ │UI Repo 2│   . . .   │UI Repo N│
  │ ^5.0.0  │ │ ^5.0.0  │           │ ^5.0.0  │
  └─────────┘ └─────────┘           └─────────┘

  Each repo's package.json:
  "@yourorg/platform": "^5.0.0"
```

-----

## Centralized Platform Package Setup

### Repo Structure

```
platform-package/
├── package.json
├── index.js              (re-exports)
├── CHANGELOG.md
├── README.md
└── src/
    ├── ui-components.js
    ├── shared-utils.js
    ├── auth-helpers.js
    ├── api-client.js
    └── theme-config.js
```

### package.json

```json
{
  "name": "@yourorg/platform",
  "version": "5.0.0",
  "description": "Centralized platform package for all shared internal dependencies",
  "main": "index.js",
  "dependencies": {
    "@yourorg/ui-components": "2.3.2",
    "@yourorg/shared-utils": "3.1.4",
    "@yourorg/auth-helpers": "1.5.0",
    "@yourorg/api-client": "4.0.1",
    "@yourorg/theme-config": "1.2.0"
  },
  "peerDependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "publishConfig": {
    "registry": "https://npm.pkg.github.com"
  }
}
```

### index.js (Re-exports)

```js
// Re-export all internal packages for explicit, safe imports
// This avoids reliance on npm hoisting behavior

// UI Components
export {
  Button,
  Modal,
  Table,
  Card,
  Input,
  Select
} from '@yourorg/ui-components';

// Shared Utilities
export {
  formatDate,
  debounce,
  throttle,
  deepMerge
} from '@yourorg/shared-utils';

// Auth Helpers
export {
  useAuth,
  AuthProvider,
  withAuth
} from '@yourorg/auth-helpers';

// API Client
export {
  apiClient,
  useApi,
  ApiProvider
} from '@yourorg/api-client';

// Theme Config
export {
  theme,
  ThemeProvider,
  useTheme
} from '@yourorg/theme-config';
```

### Alternatively: Separate Entry Points (Recommended for Larger Packages)

Instead of one giant `index.js`, you can use separate entry points:

```js
// src/ui-components.js
export * from '@yourorg/ui-components';

// src/shared-utils.js
export * from '@yourorg/shared-utils';

// src/auth-helpers.js
export * from '@yourorg/auth-helpers';
```

Consumers then import like:

```js
import { Button, Modal } from '@yourorg/platform/ui-components';
import { formatDate } from '@yourorg/platform/shared-utils';
```

For this to work, add an `exports` field to `package.json`:

```json
{
  "exports": {
    ".": "./index.js",
    "./ui-components": "./src/ui-components.js",
    "./shared-utils": "./src/shared-utils.js",
    "./auth-helpers": "./src/auth-helpers.js",
    "./api-client": "./src/api-client.js",
    "./theme-config": "./src/theme-config.js"
  }
}
```

-----

## Consuming Repo Setup (Each of the 10-15 UI Repos)

### package.json (One-Time Change)

**Before (old way — direct dependencies):**

```json
{
  "name": "ui-app-1",
  "dependencies": {
    "@yourorg/ui-components": "2.3.1",
    "@yourorg/shared-utils": "3.1.3",
    "@yourorg/auth-helpers": "1.4.9",
    "react": "^18.2.0",
    "axios": "^1.6.0"
  }
}
```

**After (new way — single platform dependency):**

```json
{
  "name": "ui-app-1",
  "dependencies": {
    "@yourorg/platform": "^5.0.0",
    "react": "^18.2.0",
    "axios": "^1.6.0"
  }
}
```

### Import Changes in App Code

If using re-exports:

```js
// Before
import { Button } from '@yourorg/ui-components';
import { formatDate } from '@yourorg/shared-utils';

// After (Option A: single entry point)
import { Button, formatDate } from '@yourorg/platform';

// After (Option B: separate entry points — recommended)
import { Button } from '@yourorg/platform/ui-components';
import { formatDate } from '@yourorg/platform/shared-utils';
```

> **Note:** If you want to avoid changing import paths across all apps, you can skip the re-export approach entirely and rely on npm’s dependency hoisting. When a repo installs `@yourorg/platform`, npm hoists its dependencies to the top-level `node_modules`, so `import { Button } from '@yourorg/ui-components'` continues to work without any code changes. However, re-exports are more explicit and reliable.

-----

## CI Pipeline Configuration

### The Lockfile Consideration

By default, `npm ci` locks to the exact versions in `package-lock.json` and will **not** pick up newer versions of `@yourorg/platform`.

**Recommended: Add an update step before install.**

```yaml
# GitHub Actions Example
steps:
  - name: Checkout
    uses: actions/checkout@v4

  - name: Setup Node
    uses: actions/setup-node@v4
    with:
      node-version: '20'
      registry-url: 'https://npm.pkg.github.com'

  - name: Update platform package
    run: npm update @yourorg/platform
    env:
      NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  - name: Install dependencies
    run: npm install
    env:
      NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  - name: Build
    run: npm run build

  - name: Test
    run: npm test
```

**Alternative: Use `npm install` instead of `npm ci`** — this resolves the latest compatible versions fresh each time. Simpler, but slightly slower.

-----

## Versioning Strategy

### Semver Rules for the Platform Package

|Change Type                             |Version Bump             |Example                          |Auto-picked up by `^5.0.0`?               |
|----------------------------------------|-------------------------|---------------------------------|------------------------------------------|
|Vulnerability fix in an internal package|**Patch** (5.0.0 → 5.0.1)|Fix XSS in ui-components         |✅ Yes                                     |
|New component or utility added          |**Minor** (5.0.1 → 5.1.0)|Add DatePicker to ui-components  |✅ Yes                                     |
|Remove/rename a package or component    |**Major** (5.1.0 → 6.0.0)|Remove deprecated auth-helpers v1|❌ No (intentional, requires manual update)|

### Key Principle

- **Patch and minor updates propagate automatically** to all 10-15 repos.
- **Major updates require a one-time manual update** in each repo — this is intentional and provides a safety net against breaking changes.

-----

## Vulnerability Fix Workflow

```
1. Vulnerability found in @yourorg/ui-components@2.3.1
          │
          ▼
2. Fix the vulnerability in the ui-components repo
   Publish @yourorg/ui-components@2.3.2
          │
          ▼
3. Update the platform package repo:
   Change: "@yourorg/ui-components": "2.3.2"
   Bump platform version: 5.0.0 → 5.0.1
   Publish @yourorg/platform@5.0.1
          │
          ▼
4. DONE. Do NOT touch any of the 10-15 UI repos.
          │
          ▼
5. Next time any UI repo's CI pipeline runs:
   → npm update @yourorg/platform
   → ^5.0.0 resolves to 5.0.1
   → Which pulls @yourorg/ui-components@2.3.2
   → Vulnerability is patched
   → Build and tests run
   → Deploys with the fix
```

**Total manual effort: Update 1 file in 1 repo. Everything else is automatic.**

-----

## Why `^5.0.0` and NOT `latest`

|Aspect                               |`latest`       |`^5.0.0` (Recommended)        |
|-------------------------------------|---------------|------------------------------|
|Gets patch fixes automatically       |✅              |✅                             |
|Gets minor updates automatically     |✅              |✅                             |
|Gets breaking changes automatically  |✅ **Dangerous**|❌ **Safe**                    |
|Protection from bad publishes        |None           |Semver boundary               |
|Accidental major bump breaks all apps|Yes            |No                            |
|Rollback possible                    |Difficult      |Easy — pin to specific version|
|Staged rollout possible              |No             |Yes — test one app first      |

-----

## Optional: Trigger All Pipelines After a Critical Fix

If a vulnerability is critical and you need all 10-15 repos to rebuild immediately (rather than waiting for the next natural pipeline run), use a simple trigger script:

### GitHub Actions

```bash
#!/bin/bash
# trigger-all-builds.sh

REPOS=(
  "ui-app-1"
  "ui-app-2"
  "ui-app-3"
  "ui-app-4"
  "ui-app-5"
  "ui-app-6"
  "ui-app-7"
  "ui-app-8"
  "ui-app-9"
  "ui-app-10"
)

for repo in "${REPOS[@]}"; do
  echo "Triggering build for $repo..."
  gh workflow run build.yml \
    --repo "yourorg/$repo" \
    --ref main
done

echo "All builds triggered."
```

### GitLab CI

```bash
#!/bin/bash
REPOS=("111" "222" "333")  # GitLab project IDs

for project_id in "${REPOS[@]}"; do
  curl --request POST \
    --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
    "https://gitlab.com/api/v4/projects/${project_id}/pipeline" \
    --form "ref=main"
done
```

-----

## Rollback Strategy

If a platform update breaks something:

**Quick rollback (per repo):**

```json
// Temporarily pin to the last known good version
"@yourorg/platform": "5.0.0"
```

**Fix forward:**

```
1. Fix the issue in the internal package
2. Publish a new patch of the internal package
3. Update and publish a new patch of @yourorg/platform
4. Repos pick it up on next build
```

-----

## Benefits Summary

|Benefit                   |Description                                                                       |
|--------------------------|----------------------------------------------------------------------------------|
|**Single point of update**|Fix a vulnerability once, publish once, all repos get it                          |
|**No manual repo updates**|`^` semver range handles patch/minor propagation automatically                    |
|**Safety net**            |Major version boundary prevents accidental breaking changes                       |
|**Full traceability**     |Every platform version is traceable; you know exactly what each app was built with|
|**Works locally**         |Developers get the same versions locally, not just in CI                          |
|**Standard npm pattern**  |No custom scripts, no external tooling, no bots                                   |
|**Easy rollback**         |Pin to a previous version if something goes wrong                                 |
|**Scalable**              |Works the same whether you have 10 repos or 100                                   |

-----

## One-Time Migration Checklist

- [ ] Create the `@yourorg/platform` repo
- [ ] Add all 4-5 internal packages as dependencies
- [ ] Set up re-exports (optional but recommended)
- [ ] Publish `@yourorg/platform@5.0.0` to private registry
- [ ] For each of the 10-15 UI repos:
  - [ ] Replace individual internal package dependencies with `"@yourorg/platform": "^5.0.0"`
  - [ ] Update import paths (if using re-exports)
  - [ ] Update CI pipeline to include `npm update @yourorg/platform` step
  - [ ] Run full test suite to verify
- [ ] Document the versioning strategy for the team
- [ ] Set up CHANGELOG.md in the platform repo
